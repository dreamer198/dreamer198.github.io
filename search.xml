<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从本地文件夹到 GitHub 新仓库：一步步推送指南</title>
    <url>/2025/11/06/Github-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93-%3E%E8%BF%9C%E7%A8%8B/</url>
    <content><![CDATA[这篇文章记录如何把“本地已有代码文件夹”推送到一个全新的 GitHub 仓库。默认假设：你本地已经有一个项目文件夹，但 GitHub 上还没有对应的远程仓库。
前置条件
已安装 Git（Linux）
拥有 GitHub 账号
可选：安装 GitHub CLI（gh）以命令行创建仓库

# 查看 Git 版本（确认已安装）git --version

一、初始化本地仓库并做首个提交
进入项目文件夹

cd /path/to/your-project


初始化 Git 仓库

git init


设置用户名和邮箱（一次性全局设置）

git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的邮箱&quot;


创建&#x2F;完善 .gitignore（避免把无关文件提交上去）

示例（按需取用）：
# 编译/缓存node_modules/*.log.DS_Store__pycache__/*.py[cod].env.idea/.vscode/dist/build/public/


暂存并提交

git add .git commit -m &quot;chore: initial commit&quot;


注意：首次提交前建议检查 git status，确认不会把隐私文件、超大文件误传。

二、在 GitHub 创建一个“空”仓库创建仓库时，务必保持“不要勾选”自动生成 README &#x2F; .gitignore &#x2F; License，这样远程是完全空的，推送更顺畅。
方式 A：网页创建（GUI）
打开 https://github.com/new  
填写仓库名（例如：your-repo）
可选：选择 Public &#x2F; Private
不勾选 README &#x2F; .gitignore &#x2F; License
Create repository

创建成功后页面会显示两种远程地址：HTTPS 和 SSH，任选其一。
方式 B：命令行创建（GitHub CLI，可选）# 进入你的项目目录后执行（交互式创建）gh repo create your-repo --public --source=. --remote=origin --push


如果不想立即 push，可以去掉 --push，稍后自己执行 git push。
若无 gh，可跳过本节，用网页方式创建。

三、配置远程地址（HTTPS 或 SSH）你可以二选一：
选项 1：使用 HTTPS（简单、开箱即用）git remote add origin https://github.com/&lt;your-username&gt;/&lt;your-repo&gt;.git
推送时可能需要输入 GitHub 账号与 Token（个人访问令牌）。Token 可在 GitHub → Settings → Developer settings → Personal access tokens 中创建。
选项 2：使用 SSH（推荐长期使用）首次使用需配置 SSH Key：

生成密钥（若不存在）

ssh-keygen -t ed25519 -C &quot;你的邮箱&quot;# 一路回车，默认保存在 ~/.ssh/id_ed25519 和 id_ed25519.pub

启动 ssh-agent 并添加私钥

eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_ed25519

复制公钥内容，添加到 GitHub → Settings → SSH and GPG keys

cat ~/.ssh/id_ed25519.pub# 复制输出到 GitHub

测试连接

ssh -T git@github.com

配置远程地址（SSH）

git remote add origin git@github.com:&lt;your-username&gt;/&lt;your-repo&gt;.git

四、推送到远程（默认分支 main）
确认当前分支名（建议使用 main）

git branch
若仍是 master，可重命名：
git branch -m master main


首次推送并建立追踪关系

git push -u origin main

成功后，刷新 GitHub 仓库页面即可看到代码。
五、后续协作的常用命令
提交新改动：

git add .git commit -m &quot;feat: 描述本次改动&quot;git push


拉取远程更新：

git pull --rebase


查看远程：

git remote -v

常见问题排查（FAQ）
推送被拒绝：rejected non-fast-forward


原因：远程不是空仓库，可能自动生成了 README 等
解决：
方法 A：删除远程的自动文件，保持远程为空；
方法 B：git pull --rebase origin main 后再 git push




Permission denied (publickey)


原因：SSH Key 未正确配置或未添加到 GitHub
自查：

ssh -T git@github.com

检查 ~/.ssh/id_ed25519.pub 是否已添加到 GitHub → SSH keys


需要输入账号密码&#x2F;Token


使用 HTTPS 推送时，GitHub 需要 Token 替代密码
建议改用 SSH 方式，长期更省心


大文件推不动或仓库体积过大


避免把数据集、可执行文件、编译产物提交
必要时使用 Git LFS（Large File Storage）


忘记 .gitignore，提交了不该上的文件

# 先修改 .gitignore# 然后清除索引并重新提交git rm -r --cached .git add .git commit -m &quot;chore: apply .gitignore&quot;

六、提交信息规范（推荐）为了让提交历史更清晰、可搜索，推荐遵循 Conventional Commits 规范：
基本格式：
&lt;type&gt;(&lt;scope&gt;): &lt;简要说明&gt;&lt;可选正文，多行&gt;&lt;可选页脚，例如 Closes #123 或 BREAKING CHANGE&gt;

常用类型一览：



类型
用途
示例



feat
新功能（feature）
feat(bt): add new takeoff behavior


fix
修复 bug
fix(mavros): correct FCU URL parsing


chore
非功能改动（构建脚本、依赖、初次提交）
chore: initial commit


docs
文档修改
docs: update README with usage example


style
代码格式（不影响功能）
style: reformat indentation in ListenCommand.cpp


refactor
重构（非修复非新增）
refactor(bt): simplify tick logic


test
测试相关改动
test: add unit test for JSON parser


perf
性能优化
perf(nav): improve GPS update rate


build
构建系统或依赖更改
build: switch to CMake 3.22


ci
CI 配置更改
ci: add GitHub Actions workflow


小贴士：

scope 可选，用于指明影响范围（例如模块名：bt、mavros、nav、planner 等）。
提示性提交可以在正文描述动机、做法与影响面，便于 Code Review 与后续排查。
关联问题单：在页脚使用 Closes #123 &#x2F; Refs #123，平台会自动联动。
破坏性变更：页脚使用 BREAKING CHANGE: 说明迁移指南。

示例：
git commit -m &quot;feat(bt): add new takeoff behavior&quot;git commit -m &quot;fix(mavros): correct FCU URL parsing&quot;git commit -m &quot;refactor(nav): simplify tick logic&quot;git commit -m &quot;docs: update README with usage example&quot;git commit -m &quot;chore: initial commit&quot;

结合上文流程，建议首次提交使用：
git commit -m &quot;chore: initial commit&quot;

小结
关键在于：先本地初始化并提交 → 创建“空”的远程仓库 → 添加远程 → 首次推送。
建议优先使用 SSH，减少认证麻烦；.gitignore 要尽早设置，避免把无关文件带上去。

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>版本控制</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建过程记录</title>
    <url>/2025/11/01/Blog-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[博客搭建过程记录（Hexo + Butterfly）从动机、搭建、美化到部署与后续维护
本文是对个人博客搭建与日常维护流程的系统整理，方便后续复盘与迁移到其它设备。内容包括动机、框架选择、主题美化、部署策略、写作流程、常用命令以及潜在问题展望。

1. 搭建的目的本科阶段就有“做一个属于自己的网站 &#x2F; 知识库”的想法，但迟迟没有行动。求职阶段回顾过去：学了很多，也似乎留不下系统沉淀。于是决定用博客持续记录——聚焦于学习轨迹、踩坑经验、与阶段性总结。
2. 总体搭建用时与感受网上教程非常多，原本担心复杂度较高，实际两天左右就完成了一个可用的初版。当前定位：个人学习记录，不追求花哨功能，后期只做轻量迭代（样式与体验微调）。
3. 技术栈与主题美化
框架：Hexo
主题：Butterfly
美化动作：
调整主题主色与背景图片
自定义个人简介页面（借助 GPT 快速生成前端结构）
优化导航栏结构（首页 &#x2F; 分类 &#x2F; 标签 &#x2F; 关于）
Tag 页面与 Category 页面样式微调



4. 域名与部署策略选择起初考虑买服务器（例如阿里云）自行部署，但：

额外运维成本与时间投入不划算
博客主要是“自用记录”，对性能与动态能力需求低
服务器费用不必要

最终选择 GitHub Pages 部署，另购国内域名以减少访问翻墙需求。当前体验：

缺点：图片首次加载稍慢
优点：免服务器、配置简单、可持续维护

5. 源码备份策略担心只放 GitHub Pages 最终生成内容，一旦本地源文件丢失难以恢复。策略：

建立一个私人仓库存放 Hexo 源文件（source/、配置、主题定制等）
每次写新文章：生成、部署后，再推送源码仓库保持同步

虽然步骤多一点，但可用性与安全性更高。
6. 当前写作与发布流程写新博客的操作顺序：

在 source/_posts/ 下新建 Markdown 文件（建议文件名：YYYY-MM-DD-主题.md）
准备封面或插图放到 source/img/（或主题要求的 img/ 目录）
在 themes/butterfly/_config.butterfly.yml 中（必要时）配置背景或封面引用
本地预览或直接生成 + 部署

7. 常用命令合集分步骤执行：
hexo clean      # 清理缓存与旧的 public 文件hexo g          # 生成静态文件 (hexo generate)hexo d          # 部署到 GitHub (hexo deploy)git add .git commit -m &quot;update&quot;git push        # 推送源码到私人仓库

一行整合版本：
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push]]></content>
      <categories>
        <category>随思随想</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>GitHub Pages</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetson Orin NX 系统烧录全流程（SDK Manager）</title>
    <url>/2025/11/12/Jetson-%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%BD%95/</url>
    <content><![CDATA[
适用机型：Jetson Orin NX（其它 Jetson 机型流程类似）。使用 NVIDIA 官方 Jetson SDK Manager 完成系统镜像烧录与驱动安装。



一、准备工作
一台运行 Ubuntu 20.04&#x2F;22.04 的电脑（建议 20.04&#x2F;22.04，x86_64）
USB Type‑C 数据线（支持数据传输）
Jetson SDK Manager（NVIDIA 官方工具）
Jetson Orin NX 开发板、12V 供电与显示器（HDMI&#x2F;DP）

软件下载：

SDK Manager: https://developer.nvidia.com/sdk-manager
需登录 NVIDIA 账号（没有先注册）

二、安装 SDK Manager
下载 .deb 包后双击安装，或执行：

sudo apt install ./sdkmanager_*_amd64.deb

启动并登录（Ubuntu 菜单搜索 “SDK Manager”）。

三、进入恢复模式（Recovery）
用 USB‑C 线连接 PC 与开发板短边的 Type‑C 口（USB 口旁）
断电 → 按住“REC&#x2F;Recovery”键 → 上电 → 2 秒后松手
此时风扇通常不转，PC 端可通过 lsusb 看到 NVIDIA 设备（可选检查）

常见位置提示：

REC 键与电源键位置请参考官方丝印；若不确定，尝试多次按键顺序（先按住 REC，再上电）

四、SDK Manager 配置与烧录
Select Product Category: Jetson
Hardware Configuration: 选择 Jetson Orin NX
Target Operating System: Linux for Tegra
Target Version: 选择推荐&#x2F;最新 JetPack（与板卡兼容）
选择 Host&#x2F;Target 组件（默认即可）
点击 Continue，按引导下载镜像与依赖 → 开始 Flash

烧录阶段注意：

全程保持 USB 连接稳定，避免移动触碰
若网络慢，建议先开代理或稳定网络
出现权限提示时，按指引使用 sudo 重试

五、首次开机向导烧录完成后，断开 USB，接入显示器与键鼠，重启进入系统：

设置语言、时区、用户名&#x2F;密码
进入桌面后建议先运行：

sudo apt update &amp;&amp; sudo apt upgrade -y

六、常见问题排查（FAQ）
PC 不识别设备（lsusb 看不到 NVIDIA）：


检查是否严格按“按住 REC → 上电”顺序
更换 USB‑C 线（必须支持数据）与 USB 口
更换 PC 或操作系统版本（建议 Ubuntu 20.04&#x2F;22.04）


SDK Manager 卡在下载&#x2F;校验：


切换网络或配置代理后重试
退出后重新登录 SDK Manager，会复用已下载数据


烧录成功但无法进桌面：


尝试重启；检查电源&#x2F;显示器连接
若持续异常，可重新进入 Recovery 再次烧录

七、后续建议（可选）
安装基础工具：

sudo apt install -y git curl vim htop tmux

使用 ToDesk&#x2F;向日葵等远程工具便于维护
后续进行 ROS 2、PX4、MAVROS 等环境搭建，可参考《ROS2 Humble + PX4 仿真 + MAVROS 环境搭建指南》

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Jetson</tag>
        <tag>系统烧录</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS 2 Humble + PX4 仿真 + MAVROS 环境搭建指南</title>
    <url>/2025/11/11/Onboard-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[本文记录在 Jetson Orin NX 上，从系统准备到 ROS 2 Humble、PX4 仿真与 MAVROS 的完整环境搭建的可复制流程，并列出常见问题与排查方法。力求做到：结构清晰、命令可直接粘贴、出现异常可快速定位。


环境信息
硬件：Jetson Orin NX 开发板
系统：Ubuntu 22.04（JetPack 对应版本）

推荐辅助工具
Firefox（ARM 设备上更稳定）：
下载地址：https://github.com/dreamer198/firefox


ToDesk（远程桌面）：
下载地址：https://www.todesk.com/download.html


Clash Verge（代理工具，导入订阅后提升下载速度）：
下载地址：https://clash-verge.org/zh-CN/download




提示：在 ARM 设备上某些官方软件存在兼容性或性能问题，以下组合在 Jetson 上体验更好。

安装 ROS 2 Humble官方文档参考：https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debs.html
步骤 1：配置本地化并添加源locale  # 检查 UTF-8sudo apt update &amp;&amp; sudo apt install -y localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8locale  # 验证设置sudo apt install -y software-properties-commonsudo add-apt-repository universe -ysudo apt update &amp;&amp; sudo apt install -y curlexport ROS_APT_SOURCE_VERSION=$(curl -s https://api.github.com/repos/ros-infrastructure/ros-apt-source/releases/latest | grep -F &quot;tag_name&quot; | awk -F\&quot; &#x27;&#123;print $4&#125;&#x27;)curl -L -o /tmp/ros2-apt-source.deb &quot;https://github.com/ros-infrastructure/ros-apt-source/releases/download/$&#123;ROS_APT_SOURCE_VERSION&#125;/ros2-apt-source_$&#123;ROS_APT_SOURCE_VERSION&#125;.$(. /etc/os-release &amp;&amp; echo $&#123;UBUNTU_CODENAME:-$&#123;VERSION_CODENAME&#125;&#125;)_all.deb&quot;sudo dpkg -i /tmp/ros2-apt-source.debsudo apt updatesudo apt upgrade -y

步骤 2：安装 ROS 2 与开发工具并写入环境变量sudo apt install -y ros-humble-desktopsudo apt install -y ros-dev-toolsecho &quot;source /opt/ros/humble/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc

安装 PX4 仿真环境（可选）# 获取源码git clone https://github.com/PX4/PX4-Autopilot.git --recursivecd PX4-Autopilotgit submodule update --init --recursive# 一键安装依赖bash ./Tools/setup/ubuntu.sh# 首次编译运行 Gazebo 仿真make px4_sitl gz_x500

Jetson 上 OpenCV 版本冲突修复若在编译或运行时出现：
/usr/lib/cmake/opencv4/OpenCVModules.cmake:172 (message):The imported target &quot;opencv_core&quot; references the file &quot;/usr/lib/libopencv_core.so.4.8.0&quot; but this file does not exist.

原因：JetPack 自带的 OpenCV 与 ROS 2 Humble 期望版本不一致，导致链接缺失。
解决步骤：
sudo apt updatesudo apt install -y &#x27;nvidia-opencv*&#x27;

验证：
ldconfig -p | grep opencv_core

更多参考：https://forums.developer.nvidia.com/t/opencv-libraries-missing-or-links-are-broken-on-a-fresh-install/335400
&gt; 若启动后出现提示：`Preflight Fail: No connection to the GCS`，可在 MAVLink 控制台执行：&gt; ```bash&gt; param set NAV_DLL_ACT 0

临时绕过对地面站的要求（仅用于仿真调试，不建议长期使用）。

安装 MAVROS
源码仓库：https://github.com/mavlink/mavros
教程参考：https://blog.csdn.net/huahua19891221/article/details/137724488

sudo apt install -y ros-$ROS_DISTRO-mavros ros-$ROS_DISTRO-mavros-extraswget https://gitee.com/tyx6/mytools/raw/main/mavros/install_geographiclib_datasets.shchmod a+x ./install_geographiclib_datasets.shsudo ./install_geographiclib_datasets.sh

创建 ROS 2 工作空间mkdir -p ~/ros2_ws/srccd ~/ros2_ws/src

拉取依赖与项目代码1) BehaviorTree.CPPgit clone https://github.com/BehaviorTree/BehaviorTree.CPP.gitcd BehaviorTree.CPPgit checkout 4.7.2cd ..

2) onboard 项目（私有仓库）onboard 为私有仓库，需向作者获取 token 后再执行 clone：
git clone https://&lt;token&gt;@github.com/dreamer198/onboard.git

安装 JSON 头文件依赖：
sudo apt-get install -y nlohmann-json3-dev

编译与环境配置在工作空间根目录编译（如不需要 GROOT 可视化，关闭 ZeroMQ 接口）：
cd ~/ros2_wscolcon build --cmake-args -DBTCPP_GROOT_INTERFACE=OFFecho &quot;source ~/ros2_ws/install/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc

运行与测试1. 启动 PX4 Gazebo 仿真（示例：3 台无人机）cd ~/PX4-AutopilotPX4_SYS_AUTOSTART=4001 PX4_SIM_MODEL=gz_x500 PX4_GZ_MODEL_POSE=&quot;0,0&quot; ./build/px4_sitl_default/bin/px4 -i 0PX4_GZ_STANDALONE=1 PX4_SYS_AUTOSTART=4001 PX4_GZ_MODEL_POSE=&quot;1,0&quot; PX4_SIM_MODEL=gz_x500 ./build/px4_sitl_default/bin/px4 -i 1PX4_GZ_STANDALONE=1 PX4_SYS_AUTOSTART=4001 PX4_GZ_MODEL_POSE=&quot;0,1&quot; PX4_SIM_MODEL=gz_x500 ./build/px4_sitl_default/bin/px4 -i 2

2. 启动机载控制主节点与通信节点# 启动主控制（uav_id 与端口需与 PX4 实例对应）ros2 launch onboard_control mainTree.launch.py uav_id:=1 fcu_url:=&quot;udp://:14540@127.0.0.1:14557&quot;ros2 launch onboard_control mainTree.launch.py uav_id:=2 fcu_url:=&quot;udp://:14541@127.0.0.1:14558&quot;ros2 launch onboard_control mainTree.launch.py uav_id:=3 fcu_url:=&quot;udp://:14542@127.0.0.1:14559&quot;# 启动命令发布器ros2 run onboard_comunication send_cmd# 启动状态接收器ros2 run onboard_comunication receive_status

3. 成功判定在 receive_status 终端可监听到全部无人机状态；在 send_cmd 按约定格式发布指令，可观察 Gazebo 中无人机执行对应动作。
成功标准：

所有 PX4 实例进入正常飞控循环，无持续错误输出。
MAVROS 与机载节点能正确收发心跳与状态消息。
指令发布后延迟在可接受范围（通常 &lt; 200 ms）。
多机之间不存在端口冲突（如 14540/14557 组合互不重复）。

官方与仓库
ROS 2 Humble 安装文档：https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debs.html
PX4 仓库：https://github.com/PX4/PX4-Autopilot
MAVROS 仓库：https://github.com/mavlink/mavros
GeographicLib 数据集脚本（镜像）：https://gitee.com/tyx6/mytools

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Jetson</tag>
        <tag>环境配置</tag>
        <tag>ROS2</tag>
        <tag>PX4</tag>
        <tag>MAVROS</tag>
        <tag>无人机</tag>
      </tags>
  </entry>
  <entry>
    <title>PX4+Gazebo+MAVROS+Onboard 多机仿真与实测启动指南</title>
    <url>/2025/11/14/PX4%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[概述本文整理了使用 PX4 + Gazebo + MAVROS + Onboard 控制程序进行单机与多机仿真，以及对应的实测（真实飞控硬件）启动命令与注意事项。适合快速搭建与验证多机集群控制链路。包含四种场景：

单机仿真
多机仿真（PX4 SITL 多实例）
单机实测（连接真实飞控）
多机实测（多块飞控 + 多机载电脑）

环境说明
PX4 版本：SITL，使用 px4_sitl_default 构建。
Gazebo：使用 PX4 官方支持的 Gazebo (可能是 classic 或 Garden，命令中使用 gz_x500 模型)。
ROS 版本：ROS 2（适配 MAVROS2 &#x2F; onboard 控制程序）。
地面站：QGroundControl (QGC) 用于设置真实飞控的 MAV_SYS_ID。


说明：多实例仿真中通过环境变量和 -i 指定 PX4 实例编号，该编号会映射为对应的 MAV 系统 ID。MAVROS 端通过 fcu_url 指定与 PX4 通信的 UDP 端口或串口。请确保端口与实例一一对应。

情况 1：单机仿真启动 PX4 + GazeboPX4_SYS_AUTOSTART=4001 PX4_SIM_MODEL=gz_x500 ./build/px4_sitl_default/bin/px4 -i 0
启动 MAVROS + Onboard 控制ros2 launch onboard_control mainTree.launch.py uav_id:=1 fcu_url:=&quot;udp://:14540@127.0.0.1:14557&quot;

情况 2：多机仿真启动多个 PX4 SITL 实例，并为每架无人机分配初始位姿与系统 ID。
启动 PX4 多实例# 实例 0PX4_SYS_AUTOSTART=4001 PX4_SIM_MODEL=gz_x500 PX4_GZ_MODEL_POSE=&quot;0,0&quot; ./build/px4_sitl_default/bin/px4 -i 0# 实例 1PX4_GZ_STANDALONE=1 PX4_SYS_AUTOSTART=4001 PX4_GZ_MODEL_POSE=&quot;1,0&quot; PX4_SIM_MODEL=gz_x500 ./build/px4_sitl_default/bin/px4 -i 1# 实例 2PX4_GZ_STANDALONE=1 PX4_SYS_AUTOSTART=4001 PX4_GZ_MODEL_POSE=&quot;0,1&quot; PX4_SIM_MODEL=gz_x500 ./build/px4_sitl_default/bin/px4 -i 2

提示：PX4_GZ_MODEL_POSE 用于指定模型在 Gazebo 中的初始位置 (x,y)。PX4_GZ_STANDALONE=1 用于第二及后续实例防止与第一个实例的 Gazebo 插件冲突。

启动各自的 MAVROS + Onboard 控制ros2 launch onboard_control mainTree.launch.py uav_id:=1 fcu_url:=&quot;udp://:14540@127.0.0.1:14557&quot;ros2 launch onboard_control mainTree.launch.py uav_id:=2 fcu_url:=&quot;udp://:14541@127.0.0.1:14558&quot;ros2 launch onboard_control mainTree.launch.py uav_id:=3 fcu_url:=&quot;udp://:14542@127.0.0.1:14559&quot;

PX4 实例与端口对应关系


实例 -i
MAV_SYS_ID
PX4 UDP 输入端口
MAVROS fcu_url 示例
对应参数 tgt_system



0
1
14540
udp:&#x2F;&#x2F;:14540@127.0.0.1:14557
1


1
2
14541
udp:&#x2F;&#x2F;:14541@127.0.0.1:14558
2


2
3
14542
udp:&#x2F;&#x2F;:14542@127.0.0.1:14559
3



规范建议：为每个无人机使用不同的 ROS 2 namespace，避免话题与 TF 树冲突。例如：/uav1, /uav2, /uav3。

注意事项
每个 PX4 实例的 -i 必须唯一，对应不同的 MAV_SYS_ID。
MAVROS 的 fcu_url 端口号需与对应 PX4 的输入端口匹配。
多机仿真&#x2F;实测时应区分 ROS namespace。
若出现心跳冲突，检查是否有重复的系统 ID 或端口占用。
建议在 QGC 中确认参数 MAV_SYS_ID 与仿真&#x2F;控制端配置一致。

情况 3：单机实测（真实飞控）连接真实飞控的串口（示例为 /dev/ttyACM0，波特率 57600）：
ros2 launch onboard_control mainTree.launch.py uav_id:=1 fcu_url:=&quot;serial:///dev/ttyACM0:57600&quot;

若使用不同接口（如 /dev/ttyUSB0），替换设备路径即可。

情况 4：多机实测多块飞控 + 多机载电脑或同一机载电脑的多串口：
ros2 launch onboard_control mainTree.launch.py uav_id:=1 fcu_url:=&quot;serial:///dev/ttyACM0:57600&quot;ros2 launch onboard_control mainTree.launch.py uav_id:=2 fcu_url:=&quot;serial:///dev/ttyACM1:57600&quot;ros2 launch onboard_control mainTree.launch.py uav_id:=3 fcu_url:=&quot;serial:///dev/ttyACM2:57600&quot;
在实测前需使用 QGC 分别设置每块飞控的 MAV_SYS_ID，保证：

与对应启动命令中的 uav_id 一致
集群内不重复

常见问题排查


问题
可能原因
排查建议



无法连接 MAVROS
端口号&#x2F;串口不对
确认 fcu_url 与实际端口，UDP 是否被防火墙阻挡


多机互相干扰
系统 ID 重复
检查 -i &#x2F; MAV_SYS_ID 设置以及 QGC 参数


话题混杂
未使用 namespace
在 launch 文件中增加 namespace 参数


位姿重叠
初始 pose 未区分
调整 PX4_GZ_MODEL_POSE 各实例坐标


]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ROS2</tag>
        <tag>PX4</tag>
        <tag>MAVROS</tag>
        <tag>Gazebo</tag>
        <tag>多机</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2 自定义消息接口</title>
    <url>/2025/11/05/ROS2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[ROS2 自定义消息接口：五步完成（含无人机集群示例）本文以无人机（UAV）集群通信为例，从零开始完成 ROS 2 自定义消息接口（topic&#x2F;message）的创建、编译、验证与使用。最终会得到一个接口包 onboard_msgs，内含两类消息：OnboardCommand 与 OnboardState。


适用环境（示例命令为 Linux + bash）：

ROS 2 Humble
已创建工作空间 ~/ros2_ws 并包含 src 目录
构建工具：colcon；构建类型：ament_cmake

五步法总览
创建接口包（ament_cmake + rosidl）
在 msg/ 目录编写消息（.msg）
配置 CMakeLists.txt
配置 package.xml
编译并验证接口


1) 创建接口包cd ~/ros2_ws/srcros2 pkg create onboard_msgs \  --build-type ament_cmake \  --dependencies rosidl_default_generators\  --license Apache-2.0
–dependencies后面跟接口定义的消息所需的依赖，rosidl_default_generators为必须项
进入包目录并创建接口文件夹：
cd onboard_msgsmkdir -p msg


2) 定义消息（.msg）2) 定义消息（.msg）根据无人机集群业务，定义三个消息：命令、参数、多机状态。根据无人机集群业务，定义两类消息：命令与多机状态。msg/OnboardCommand.msg在 msg/OnboardCommand.msg 中：
uint16 target_id   # 目标无人机编号string name        # 命令名称string params      # 命令参数（JSON 格式）
uint16 target_id	# 目标无人机编号在 msg/OnboardState.msg 中：
uint16 uav_id     # 无人机编号float64 lat_deg   # 纬度float64 lon_deg   # 经度float64 alt_msl   # 平均海平面高度float32 battery   # 电量百分比

建议的包结构（节选）：
onboard_msgs/├─ CMakeLists.txt├─ package.xml└─ msg/   ├─ OnboardCommand.msg   └─ OnboardState.msg

3) 配置 CMakeLists.txt在包根目录打开 CMakeLists.txt，加入如下关键段落（保留已有的最低模板行）：
cmake_minimum_required(VERSION 3.8)project(onboard_msgs)find_package(ament_cmake REQUIRED)find_package(rosidl_default_generators REQUIRED)# 声明需要生成的接口rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;  &quot;msg/OnboardCommand.msg&quot;  &quot;msg/OnboardState.msg&quot;)ament_package()


4) 配置 package.xml确保依赖与接口生成组声明完整：
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-model href=&quot;http://download.ros.org/schema/package_format3.xsd&quot; schematypens=&quot;http://www.w3.org/2001/XMLSchema&quot;?&gt;&lt;package format=&quot;3&quot;&gt;  &lt;name&gt;onboard_msgs&lt;/name&gt;  &lt;version&gt;0.0.1&lt;/version&gt;  &lt;description&gt;TO DO&lt;/description&gt;  &lt;maintainer email=&quot;you@example.com&quot;&gt;Your Name&lt;/maintainer&gt;  &lt;license&gt;Apache-2.0&lt;/license&gt;  &lt;!-- 构建工具 --&gt;  &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;  &lt;!-- 用于生成接口代码 --&gt;  &lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;  &lt;!-- 运行期 --&gt;  &lt;!-- 用于供其它包调用接口 --&gt;  &lt;depend&gt;rosidl_default_runtime&lt;/depend&gt;  &lt;!-- 用于声明该功能包是一个消息接口功能包，必须包含 --&gt;  &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;  &lt;export&gt;    &lt;build_type&gt;ament_cmake&lt;/build_type&gt;  &lt;/export&gt;&lt;/package&gt;


5) 编译与环境加载在工作空间根目录编译该包，并加载环境：
cd ~/ros2_wscolcon build --packages-select onboard_msgssource install/setup.bash

验证接口是否可见：
ros2 interface list | grep onboard_msgs

查看具体定义：
ros2 interface show onboard_msgs/msg/OnboardCommandros2 interface show onboard_msgs/msg/OnboardState


CLI 快速试用（发布&#x2F;回显）使用 ros2 topic pub 和 ros2 topic echo 快速验证消息格式与编解码是否正常。
发布一条命令到 /uav/cmd：
ros2 topic pub /uav/cmd onboard_msgs/msg/OnboardCommand \  &#x27;&#123;target_id: 1, name: &quot;Takeoff&quot;, params: &quot;&#123;\&quot;alt\&quot;: 5.0&#125;&quot;&#125;&#x27;

回显无人机状态（若已有节点发布到 /uav/state）：
ros2 topic echo /uav/state onboard_msgs/msg/OnboardState

提示：在 bash 中传 JSON 时，注意对双引号进行转义，或改用 YAML 多行字面量方式避免转义错误。

在其他包中使用该接口（CMake 示例）若有消费该消息的 C++ 包，需在其 CMakeLists.txt 中：
find_package(ament_cmake REQUIRED)find_package(rclcpp REQUIRED)find_package(onboard_msgs REQUIRED)add_executable(my_node src/my_node.cpp)ament_target_dependencies(my_node rclcpp onboard_msgs)install(TARGETS my_node DESTINATION lib/$&#123;PROJECT_NAME&#125;)ament_package()

并在 package.xml 中添加：
&lt;depend&gt;onboard_msgs&lt;/depend&gt;


常见错误与排查
忘记在 CMakeLists.txt 的 rosidl_generate_interfaces 中加入新 .msg 文件 → 重新添加后再 colcon build。
未在 package.xml 中加入 &lt;depend&gt;rosidl_default_runtime&lt;/depend&gt; → 其它包找不到生成的类型。
构建后未 source install/setup.bash → 终端会找不到接口定义。
CLI 发布 JSON 参数时引号转义错误 → 建议用单引号包裹、内部双引号转义，或改用 YAML 方式。
多机&#x2F;多命名空间未区分 → 为每架 UAV 使用不同命名空间（如 /uav1/..、/uav2/..）。


参考
ROS 2 Interface Definition: https://design.ros2.org/articles/interface_definition.html
Tutorials: https://docs.ros2.org

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ROS2</tag>
        <tag>无人机</tag>
        <tag>接口</tag>
        <tag>自定义消息</tag>
        <tag>集群通信</tag>
      </tags>
  </entry>
</search>
